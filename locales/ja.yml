ja:
  introduction: "Hacarus Visual Inspection Api"
  introductionMessage: "
  ハカルスはメーカーとメディカル事業に向け、軽量で説明可能なAIソリューションズを提供しています。
  <br/><br/>
  弊社のスパースモデリングに基づいた技術は、人間のようにデータを理解できる独自の機械学習手法です。スパースモデリングは軽量に設計されているため、コンピューティングパワー、クラウド環境、および少量の学習データなどの資源の制限された環境下で特に有用です。
  <br/><br/>
  弊社のソリューションは組み込みシステムでオフライン環境かクラウドで実行できます。伝統的なディープラーニングベースの手法に比べ、資源を効率的に使用し、よりよい結果を提供します。
  <br/><br/>
  ハカルスの外観検査ソリューションの詳細を参照するには、こちらのリンク、<a href='https://hacarus.com/ja/visual-inspection/'>https://hacarus.com/ja/visual-inspection/</a> をご覧ください。また、APIへのアクセスのリクエストは<a href='https://hacarus.com/ja/contact/'>contact us</a> までご連絡ください。
  "
  introductionMessageMoreCSharp: "この外観検査用 API wrapper for C#は、あなたのC#のプロジェクトに、APIを通じて外観検査モジュールを組み込むことができます。このライブラリはC# .Net Framework 4.6.1 と .Net Core 2.0.をサポートしています。"
  introductionMessageMorePython: "このPython用外観検査SDKは、APIを用いてハカルス外観検査モジュールを使いたいソフトウェアエンジニアのために作成しています。 このAPIによって、Pythonベースのアプリケーションに外観検査モジュールを簡単に統合することができます。"
  installation: "インストール"
  installationMessagePython: "このパッケージをインストールするために、以下のコマンドを実行してください。"
  installationMessageCSharp: "このパッケージをプロジェクトにインストールするため、こちらのコマンドをPackage Manager Consoleに入力してください。"
  installationMessageMoreCSharp: "
  NuGetパッケージマネージャを使用してプロジェクトに追加することもできます。Show prerelease packagesにチェックを入れ、 HacarusVisualInspectionApi を nuget.org のリポジトリで検索してください。
  <br/><br/>
  他のインストール方法は<a href='https://www.nuget.org/packages/HacarusVisualInspectionApi/1.1.2-beta'>Nuget Package Site</a>を参照ください。"
  terms: "用語説明"
  termsMessage: "
このドキュメントの全体で使用されている用語の簡単な説明：
<br/><br/>
<b>モデル</b><br/>
モデルは一連のパラメータの設定とともに、データセットの学習データ（トレーニングデータ）をアルゴリズムに適用して、作成・学習できます。
<br/><br/>
<b>アルゴリズム</b><br/>
アルゴリズムはモデルを構成するため使用する機械学習アルゴリズムのことです。外観検査の性質と予想される精度および性能によって選択します。
<br/><br/>
<b>学習</b><br/>
新しいモデルを作成する操作です。
<br/><br/>
<b>パラメータ</b><br/>
パラメータは、学習中にアルゴリズムを適用する方法を構成するために使用されます。 例えば、最小または最大の画像解像度などがあります。
<br/><br/>
<b>データ</b><br/>
データ（アイテムとも呼ばれる)は検査の対象となる単一の製品のデータを表します。 1つのデータに1つまたは複数の画像を関連付けることができます。
例：倉庫内の梱包箱の場合、一つの箱に6つの面の画像があります。
"
  usage: "使用方法"
  usageMessage: "
始めに、下記のものが必要です。
<ul>
  <li>
    クライエントIDとクライエントシークレット
    <ul>
      <li>
        これはSDKを認証するために使用されます。
      </li>
      <li>
        認証されたユーザーはシステム機能にアクセスでき、データを追加したり、データ、アルゴリズム、モデルの一覧を取得ことができます。
      </li>
      <li>
        モデルの学習や推論を行うためにはライセンスをアクティベートする必要があります。
      </li>
    </ul>
  </li>
  <li>
    ライセンスファイル
    <ul>
      <li>
        これはライセンスをアクティベートするため使用されます。
      </li>
    </ul>
  </li>
</ul>
<ul>
  <li>
    学習画像
    <ul>
      <li>
        モデルを作成するためには、画像をアップロードして、学習データを提供する必要があります。
      </li>
      <li>
        モデルを作成するには学習データが使用されます。
      </li>
      <li>
        画像をアップロードすることで推論のためのデータを追加します。
      </li>
      <li>
        作成済みのモデルを用いてデータを推論します。
      </li>
      <li>
        サンプル画像はこちらからダウンロードすることができます。（<a href='https://drive.google.com/file/d/1Zg*gCX9gxxYjEau9j29oe0hDBuppDosh/view'>Metal Plates</a>、<a href='https://drive.google.com/file/d/1oRvEfeDfa3seEn0rFXRa1IgTUyzg0hxv/view'>Wood Blocks</a>）
        <ul>
          <li>
            モデルの作成に使用できる良品と不良品の画像とパラメータの一覧が含まれています。
          </li>
          <li>
            学習用の画像はtrainフォルダにあり、推論用の画像はpredictフォルダにあります。
          </li>
          <li>
            NGとは不良品の画像、OKとは良品の画像という意味です。
          </li>
        </ul>
      </li>
    </ul>
</ul>"
  initialization: "初期化"
  initializationMessage: "
  <ul>
    <li>
      ライブラリを初期化します。
    </li>
    <li>
      エンドポイントURLをとして入力。
    </li>
    <li>
      エンドポイントが入力されていない場合、ライブラリはデフォルトのエンドポイント https://sdd.hacarus.com/api を使用します。
    </li>
    <li>
      個別のエンドポイントURLは、リクエストに応じてHacarusから提供されます。
    </li>
  </ul>
  "
  authorization: "認証"
  authorizationMessage: "
  <ul>
    <li>
      アクセストークンを作成します。
    </li>
    <li>
      クライアントIDとクライアントシークレットをパラメータとして入力する。
    </li>
    <li>
      クライアントIDとクライアントシークレットは、リクエストに応じてHacarusから提供されます。
    </li>
  </ul>"
  sampleResponse: "レスポンスの一例"
  possibleErrors: "起こり得るエラー"
  error401: " 401 Unauthorized:"
  invalidClientId: "クライアントIDが無効です。"
  invalidClientSecret: "クライアントシークレットが無効です。"
  methods: "メソッド"
  activateLicense: "ライセンスのアクティベート"
  activateLicenseMessage: "
  <ul>
    <li>
      ライセンスをアクティベートします。
    </li>
    <li>
      ライセンスファイルをパラメータとして入力してください。
    </li>
    <li>
      ライセンスはユーザーが`Train` または `Predict`というファンクションを使用する前にアクティベートしてください。
    </li>
    <li>
      ライセンスファイルを取得するには、ハカルスにご連絡ください。
    </li>
  </ul>"
  error403: "403 Forbidden:"
  invalidLicense: "ライセンスファイルが無効。"
  licenseExists: "ライセンスはアクティベート済み。"
  getVersionNumber: "バージョン番号を取得する"
  getVersionNumberMessage: "ハカルス外観検査APIの現在のバージョン番号を取得するには、このメソッドを使用します。"
  getItems: "データを取得する"
  getItemsMessage: "
  <ul>
    <li>
      学習(`training`)と予測(`predict`)グループ化されたアップロードデータの一覧を取得します。
      <ul>
        <li>
          `training`: 学習に使用するデータ
        </li>
        <li>
          `predict`: アップロード済みのデータのうち、推論用のもの
        </li>
      </ul>
    </li>
    <li>
      結果を知るには、modelsのキーを確認し、確認したいモデルを調べます。
    </li>
    <li>
      予測の結果を分かるため、aggregatedのキーを使用し、labelを調べます。
    </li>
    <li>
      各画像の結果を確認するには、assessmentのキーを使用します。
    </li>
  </ul>
  "
  getAlgorithms:  "アルゴリズムを取得する"
  getAlgorithmsMessage: "
  <ul>
    <li>
      学習に使用できるアルゴリズムと使用できるパラメータの一覧をリストで返します。
    </li>
    <li>
      アルゴリズムの説明について、<a href='https://github.com/hacarus/HacarusVisualInspectionApi/blob/master/%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%B9%E3%83%8E%E3%83%BC%E3%83%88%20v0.pdf'>こちら</a>をご覧ください。
    </li>
  </ul>
  "
  possibleError: "起こり得るエラー"
  error404: "404 NotFound:"
  noAlgorithm: "利用可能なアルゴリズムがありません。 この問題が発生した場合はHacarusに連絡してください。"
  getModels: "モデルを取得する"
  getModelsMessage: "
  <ul>
    <li>
      データを推論するのに使用できる作成済みモデルのリストを取得します。
    </li>
    <li>
      モデルIDが渡されなかった場合（`%{serve}`メソッドを使用して）、`active`が`%{true}`のモデルをデフォルトとして使用します。
    </li>
    <li>
      `status`キーは、モデルが`active`か`failed`かを示します。
      <ul>
        <li>
          `status`が `active`のモデルは正常に作成され、予測に使用できます
        </li>
        <li>
          `status`が `failed`のモデルは作成に失敗し、予測には使用できません
        </li>
      </ul>
    </li>
  </ul>
  "
  deleteModels: "モデルを削除する"
  deleteModelsMessage: "
  <ul>
    <li>
      モデルを削除する
    </li>
    <li>
      現在アクティブなモデル(`default_context` is `true`)を削除できません。
    </li>
    <li>
      結果を確認するには、`%{getModels}` メソッドを利用し、各データのキーstatusをチェックして下ださい
    </li>
  </ul>
  "
  modelDoesNotExist: "Model with model id sent does not exist"
  train: "学習"
  algorithmParameter: "アルゴリズムパラメータ"
  trainMessage: "
  <ul>
    <li>
      推論に使用するモデルを作成します。
    </li>
    <li>
      モデルの学習に使用するデータIDの配列を含むオプションのパラメータを入力します。
    </li>
    <li>
      アルゴリズムの設定を調整するため%{algorithmParameter}の配列を入力します。
    </li>
    <li>
      新しく作成したモデルを確認するには、`%{getModels}`メソッドを使用します。
    </li>
  </ul>
  "
  invalidId: "少なくとも1つのデータIDがクライアントに属していないか、無効か、または存在しません。"
  addItem: "データを追加する"
  addItemMessage: "
  <ul>
    <li>
      このメソッドを使用して、学習のためのデータをアップロードしてラベルを付けます。
    </li>
    <li>
      データに良品または不良品としてラベルを付ける場合は、`%{isGood}`パラメータをブール値で`%{true}`（良品）または`%{false}`（不良品）に設定します。
    </li>
  </ul>
  "
  addItemMessageMoreCSharp: "
  <ul>
    <li>
      このメソッドを使用して、推論のためのデータをアップロードしてラベルを付けます。
    </li>
    <li>
      `Files`パラメータを使用して`FileModel`の配列を渡します。 `FileModel`は`FileName`と`ContentType`のプロパティを持ちます。
    </li>
    <li>
      FileModelを作成をするには、`FileModel File = new FileModel() `または、 `FileModel File = new FileModel(\"FileName\", \"ContentType\")`を使用してください。
    </li>
    <li>
      アップロードしたデータを確認するには、`GetItems（）`メソッドを使用します。
    </li>
    <li>
      画像のファイル名はデータID(`item_id`)として使用します。
    </li>
    <li>
      サポートされているファイル形式：`png`、`jpeg`、`tiff`
    </li>
  </ul>
  "
  addItemMessageMorePython: "
  <ul>
    <li>
      このメソッドを使用して、推論のためのデータをアップロードしてラベルを付けます。
    </li>
    <li>
      アップロードしたデータを確認するには、`get_items（）`メソッドを使用します。
    </li>
    <li>
      画像のファイル名はデータID(`item_id`)として使用します。
    </li>
    <li>
      サポートされているファイル形式：`png`、`jpeg`、`tiff`
    </li>
  </ul>
  "
  error400: "400 BadRequest:"
  invalidFile: "ファイル名かファイル形の無効。"
  noImage: "アップロード用の画像が送信されていません。"
  setAnnotations: "注釈をセットする"
  setAnnotationsMessage: "
  <ul>
    <li>
      このメソッドを使用し、画像に注釈をセットします。
    </li>
    <li>
      注釈の配列とimage_idをパラメータとして使用します。
    </li>
    <li>
      注釈を全部取得するには、`GetItem`メソッドを使用します。
    </li>
  </ul>
  "
  imageIdDoesNotExist: "Image id does not exist"
  getItem: "特定のデータを取得する"
  getItemMessage: "
  <ul>
    <li>
      データIDで特定のデータを取得します。
    </li>
    <li>
      データIDは、アップロード時に画像ファイル名に基づいて割り当てられます。
    </li>
    <li>
      重要なキー:
      <ul>
        <li>
          `computed_assessment`: 予測の結果
        </li>
        <li>
          `annotations`: `%{serve}`メソッドが呼び出されたときに生成されるアノテーションのリストを含みます
        </li>
        <li>
          `raw_url`: アップロードされたファイルのURL
        </li>
        <li>
          `url`: 欠陥箇所表示ファイル（緑色のボックス）
        </li>
        <li>
          `status`: データのステータス。`pending`（推論前または予測中）または`done`（予測済み）のいずれか
        </li>
      </ul>
    </li>
  </ul>
  "
  itemIdDoesNotExists: "データIDが存在していません。"
  doesNotBelongToClient: " 指定されたデータIDのあるデータがクライアントに属していません。"
  predict: "予測"
  predictMessage: "
  <ul>
    <li>
      データは良品か不良品があるか推論します。
    </li>
    <li>
      結果を確認するには、`%{getItems}()`メソッドを使用して、各データの`good`キーを確認します。
    </li>
  </ul>
  "
  itemDoesNotExists: "送信されたデータとデータIDは存在していません。"
  noModel: "推論に使用できるモデルがないか、使用可能なモデルのステータスがのfailedです。 Trainメソッドを使用し、新しいモデルを作成してください。"
  getProcesses: "プロセスを取得する"
  getProcessesMessage: "
  <ul>
    <li>
      プロセス種類でグループされているのプロセス中の一覧を取得する。
      <ul>
        <li>
          `predicting`: 予測中に利用されているモデルIDの一覧が含まれています。
        </li>
        <li>
          `training`: トレーニング中に利用されているアルゴリズムIDの一覧が含まれています。
        </li>
      </ul>
    </li>
  </ul>
  "
  genericErrors: "一般的なエラー"
  errorUnauthorized: "メソッドを呼び出すときにまだ承認されていないエラーです。エラーを遭遇する場合、最初に`%{authorize}`メソッドを呼び出してください。"
  errorNoLicense: "メソッドを呼び出すが、ライセンスがまだアクティベートされていないか期限切れになっているときのエラーです。 遭遇したら、最初に`%{activateLicense}`メソッドを呼び出してください。"
  enLink: "../"
  jaLink: "./"
  algorithmsWithVersion: "v0.3.0リリースノート"
  algorithmOverview: "アルゴリズム概要"
  algorithmOverview1: "教師なし学習(アノテーション必要なし)"
  algorithmOverview1a: "正常画像のみから学習"
  algorithmOverview1ai: Reconstructor Inspection
  algorithmOverview1aii: Auto Classified Inspection
  algorithmOverview1b: "正常画像と少量の異常画像から学習"
  algorithmOverview1bi: Vector Inspection
  algorithmOverview1bii: Hunter Grove Inspection
  algorithmOverview2: "教師あり学習(アノテーション必要あり)"
  algorithmOverview2i: Mixed Grove Inspection
  algorithmDetails: "アルゴリズム詳細"
  descriptionOfParameters: "Description of parameters:"
  descriptionOfParametersText1: "Model size (学習サイズ): Size of the model, larger models perform better but need longer to process"
  descriptionOfParametersText2: "Range (型 : 範囲): Values used for this parameter need to be within this range of values"
  descriptionOfParametersText3: "Variable name (変数名): Technical name of the parameter in the application"
  descriptionOfParametersText4: "AutoTune (range): Parameters marked with “O” are optional. If not provided the system will automatically find the best value"
  algo1ai: "1-a-i: Reconstructor Inspection"
  algo1aiText: "正常画像のみから学習する教師なし学習モデル。推論時には新たな画像に対して、再構成誤差を計算し、その大小に基づいて異常検知を行う。"
  algo1aiTable: "
    <table class='hacarus-table'>
        <tr>
            <td>パラメータ
            </td>
            <td>変数名
            </td>
            <td>型 : 範囲
            </td>
            <td>既定値
            </td>
            <td>計算時間への影響
            </td>
            <td>精度への影響
            </td>
            <td>AutoTune (range)
            </td>
            <td>備考
            </td>
        </tr>
        <tr>
            <td>学習サイズ
            </td>
            <td>train_size
            </td>
            <td>int : [1, inf]
            </td>
            <td>10000
            </td>
            <td>大 -> 大
            </td>
            <td>大 -> 大
            </td>
            <td>x
            </td>
            <td>
            </td>
        </tr>
        <tr>
            <td>最小の検査サイズ
            </td>
            <td>min_inspection_size
            </td>
            <td>(int, int) : 0~height, 0~width
            </td>
            <td>(8, 8)
            </td>
            <td>大 -> 大
            </td>
            <td>-
            </td>
            <td>O (4, 8, 16)
            </td>
            <td>(4, 4) or (8,8) or (16,16) が経験的によい。
                <p>
                    三つの中から選んでもらうようにしたい。
            </td>
        </tr>
        <tr>
            <td>最小の検査サイズ幅
            </td>
            <td>min_inspection_step
            </td>
            <td>int : [1, inf]
            </td>
            <td>4
            </td>
            <td>大 -> 小
            </td>
            <td>大 -> 小
            </td>
            <td>x
            </td>
            <td>min_inspection_sizeの約数が望ましい。
                <p>
                    1のとき一番計算負荷がかかるが、もっとも性能がよい。
            </td>
        </tr>
        <tr>
            <td>最小の検知サイズ
            </td>
            <td>min_detected_area
            </td>
            <td>Float : [1, inf]
            </td>
            <td>None
            </td>
            <td>-
            </td>
            <td>-
            </td>
            <td>x
            </td>
            <td>検出された矩形の面積の閾値
            </td>
        </tr>
        <tr>
            <td>異常部分の拡大率
            </td>
            <td>anomaly_magnification
            </td>
            <td>(int, int) : 0~height, 0~width
            </td>
            <td>(1, 1)
            </td>
            <td>-
            </td>
            <td>-
            </td>
            <td>o(1,3,5)
            </td>
            <td>大きくすると、小さい異常部分を検出できるようになる。ただし過検出も増える。
            </td>
        </tr>
        <tr>
            <td>無視される外周からの幅
            </td>
            <td>ignore_outer
            </td>
            <td>(int, int) : 0~height, 0~width
            </td>
            <td>(0,0)
            </td>
            <td>-
            </td>
            <td>-
            </td>
            <td>x
            </td>
            <td>外周からの無視する領域の幅
                <p>
                    画像の縦, 横のピクセル数までの値にする。
            </td>
        </tr>
        <tr>
            <td>特徴量の次元
            </td>
            <td>n_components
            </td>
            <td>int : [1, inf]
            </td>
            <td>10
            </td>
            <td>大 -> 大
            </td>
            <td>大 -> ほとんど正常
                <p>
                    小 -> ほとんど異常
            </td>
            <td>o(3, 5, 10, 20, 30)
            </td>
            <td>特徴量の次元が大きいと複雑な対象でも再構成できるようになる。
            </td>
        </tr>
        <tr>
            <td>アルゴリズム反復回数
            </td>
            <td>max_iter
            </td>
            <td>Int : [1, inf]
            </td>
            <td>10
            </td>
            <td>大 -> 大
            </td>
            <td>-
            </td>
            <td>x
            </td>
            <td>少なすぎると性能が悪くなるが、ある程度大きければ、性能はそれほど変わらない。
            </td>
        </tr>
        <tr>
            <td>再構成誤差の閾値
            </td>
            <td>reconstruct_thresh
            </td>
            <td>float : [0, inf]
            </td>
            <td>2.0
            </td>
            <td>-
            </td>
            <td>大 -> ほとんど正常
                <p>
                    小 -> ほとんど異常
            </td>
            <td>O ()
            </td>
            <td>再構成誤差に対する閾値、1.5 ~ 3程度の値が経験的によい
            </td>
        </tr>
        <tr>
            <td>検知領域の異常度の閾値
            </td>
            <td>detected_area_thresh
            </td>
            <td>float : [0, inf]
            </td>
            <td>0.1
            </td>
            <td>-
            </td>
            <td>-
            </td>
            <td>O ([0.1, 0.5])
            </td>
            <td>大きすぎるとほとんど正常、小さすぎるとほとんど異常
            </td>
        </tr>
        <tr>
            <td>アルゴリズムの種類
            </td>
            <td>reconstruct_algorithm_name
            </td>
            <td>str : {‘nmf’}
            </td>
            <td>‘nmf’
            </td>
            <td>-
            </td>
            <td>-
            </td>
            <td>x
            </td>
            <td>他のタイプは後で追加されます
            </td>
        </tr>
    </table>
  "

  algo1aii: "1-a-ii: Auto Classified Inspection"
  algo1aiiText: "正常画像のみから学習する教師なし学習モデル。正常な入力画像に対して深層学習を行う。推論時には新たな画像に対して、再構成誤差を計算し、その大小に基づいて異常検知を行う。"
  algo1aiiTable: "
  <table class='hacarus-table'>
    <tr>
        <td>パラメータ
        </td>
        <td>変数名
        </td>
        <td>型 : 範囲
        </td>
        <td>既定値
        </td>
        <td>計算時間への影響
        </td>
        <td>精度への影響
        </td>
        <td>AutoTune (range)
        </td>
        <td>備考
        </td>
    </tr>
    <tr>
        <td>学習サイズ
        </td>
        <td>train_size
        </td>
        <td>int : [1, inf]
        </td>
        <td>10000
        </td>
        <td>大 -> 大
        </td>
        <td>大 -> 大
        </td>
        <td>x
        </td>
        <td>
        </td>
    </tr>
    <tr>
        <td>最小の検査サイズ
        </td>
        <td>min_inspection_size
        </td>
        <td>(int, int) : 0~height, 0~width
        </td>
        <td>(8, 8)
        </td>
        <td>大 -> 大
        </td>
        <td>-
        </td>
        <td>O (4, 8, 16)
        </td>
        <td>(4, 4) or (8,8) or (16,16) が経験的によい。
            <p>
                三つの中から選んでもらうようにしたい。
        </td>
    </tr>
    <tr>
        <td>最小の検査サイズ幅
        </td>
        <td>min_inspection_step
        </td>
        <td>int : [1, inf]
        </td>
        <td>4
        </td>
        <td>大 -> 小
        </td>
        <td>大 -> 小
        </td>
        <td>x
        </td>
        <td>min_inspection_sizeの約数が望ましい。
            <p>
                1のとき一番計算負荷がかかるが、もっとも性能がよい。
        </td>
    </tr>
    <tr>
        <td>最小の検知サイズ
        </td>
        <td>min_detected_area
        </td>
        <td>Float : [1, inf]
        </td>
        <td>None
        </td>
        <td>-
        </td>
        <td>-
        </td>
        <td>x
        </td>
        <td>検出された矩形の面積の閾値
        </td>
    </tr>
    <tr>
        <td>異常部分の拡大率
        </td>
        <td>anomaly_magnification
        </td>
        <td>(int, int) : 0~height, 0~width
        </td>
        <td>(1, 1)
        </td>
        <td>-
        </td>
        <td>-
        </td>
        <td>o(1,3,5)
        </td>
        <td>大きくすると、小さい異常部分を検出できるようになる。ただし過検出も増える。
        </td>
    </tr>
    <tr>
        <td>無視される外周からの幅
        </td>
        <td>ignore_outer
        </td>
        <td>(int, int) : 0~height, 0~width
        </td>
        <td>(0,0)
        </td>
        <td>-
        </td>
        <td>-
        </td>
        <td>x
        </td>
        <td>外周からの無視する領域の幅
            <p>
                画像の縦, 横のピクセル数までの値にする。
        </td>
    </tr>
    <tr>
        <td>層の構造
        </td>
        <td>encoding_dims
        </td>
        <td>Tuple[int]
        </td>
        <td>(128, 64, 32)
        </td>
        <td>大 -> 大
        </td>
        <td>大 -> 大
        </td>
        <td>x
        </td>
        <td>全ての値はmin_detected_areaの積より小さくしておく。
        </td>
    </tr>
    <tr>
        <td>エポック
        </td>
        <td>epochs
        </td>
        <td>int
        </td>
        <td>100
        </td>
        <td>大 -> 大
        </td>
        <td>大 -> 大
        </td>
        <td>x
        </td>
        <td>1以上の整数値
        </td>
    </tr>
    <tr>
        <td>バッチサイズ
        </td>
        <td>batch_size
        </td>
        <td>int
        </td>
        <td>256
        </td>
        <td>大 -> 大
        </td>
        <td>-
        </td>
        <td>x
        </td>
        <td>train_size より小さい 2 の累乗が好ましい。
        </td>
    </tr>
    <tr>
        <td>再構成誤差の閾値
        </td>
        <td>reconstruct_thresh
        </td>
        <td>float : [0, inf]
        </td>
        <td>2.0
        </td>
        <td>-
        </td>
        <td>大 -> ほとんど正常
            <p>
                小 -> ほとんど異常
        </td>
        <td>x
        </td>
        <td>再構成誤差に対する閾値、1.5 ~ 3程度の値が経験的によい
        </td>
    </tr>
    <tr>
        <td>検知領域の異常度の閾値
        </td>
        <td>detected_area_thresh
        </td>
        <td>float : [0, inf]
        </td>
        <td>0.1
        </td>
        <td>-
        </td>
        <td>-
        </td>
        <td>O ([0.1, 0.5])
        </td>
        <td>大きすぎるとほとんど正常、小さすぎるとほとんど異常
        </td>
    </tr>
  </table>
  "

  algo1bi: "1-b-i: Vector Inspection"
  algo1biText: "正常画像と少量の異常画像から学習する教師なし学習モデル。"
  algo1biTable: "
  <table class='hacarus-table'>
    <tr>
        <td>パラメータ
        </td>
        <td>変数名
        </td>
        <td>型 : 範囲
        </td>
        <td>既定値
        </td>
        <td>計算時間への影響
        </td>
        <td>精度への影響
        </td>
        <td>AutoTune (range)
        </td>
        <td>備考
        </td>
    </tr>
    <tr>
        <td>学習サイズ
        </td>
        <td>train_size
        </td>
        <td>int : [1, inf]
        </td>
        <td>1000
        </td>
        <td>大 -> 大
        </td>
        <td>大 -> 大
        </td>
        <td>x
        </td>
        <td>
        </td>
    </tr>
    <tr>
        <td>最小の検査サイズ
        </td>
        <td>min_inspection_size
        </td>
        <td>(int, int) : 0~height, 0~width
        </td>
        <td>(8, 8)
        </td>
        <td>大 -> 大
        </td>
        <td>-
        </td>
        <td>O (4, 8, 16)
        </td>
        <td>(4, 4) or (8,8) or (16,16) が経験的によい。
            <p>
                三つの中から選んでもらうようにしたい。
        </td>
    </tr>
    <tr>
        <td>最小の検査サイズ幅
        </td>
        <td>min_inspection_step
        </td>
        <td>int : [1, inf]
        </td>
        <td>4
        </td>
        <td>大 -> 小
        </td>
        <td>大 -> 小
        </td>
        <td>x
        </td>
        <td>min_inspection_sizeの約数が望ましい。
            <p>
                1のとき一番計算負荷がかかるが、もっとも性能がよい。
        </td>
    </tr>
    <tr>
        <td>最小の検知サイズ
        </td>
        <td>min_detected_area
        </td>
        <td>Float : [1, inf]
        </td>
        <td>None
        </td>
        <td>-
        </td>
        <td>-
        </td>
        <td>x
        </td>
        <td>検出された矩形の面積の閾値
        </td>
    </tr>
    <tr>
        <td>異常部分の拡大率
        </td>
        <td>anomaly_magnification
        </td>
        <td>(int, int) : 0~height, 0~width
        </td>
        <td>(1, 1)
        </td>
        <td>-
        </td>
        <td>-
        </td>
        <td>o(1,3,5)
        </td>
        <td>大きくすると、小さい異常部分を検出できるようになる。ただし過検出も増える。
        </td>
    </tr>
    <tr>
        <td>無視される外周からの幅
        </td>
        <td>ignore_outer
        </td>
        <td>(int, int) : 0~height, 0~width
        </td>
        <td>(0,0)
        </td>
        <td>-
        </td>
        <td>-
        </td>
        <td>x
        </td>
        <td>外周からの無視する領域の幅
            <p>
                画像の縦, 横のピクセル数までの値にする。
        </td>
    </tr>
    <tr>
        <td>データセット中の異常の割合
        </td>
        <td>contamination
        </td>
        <td>Float : [0, 0.5]
        </td>
        <td>0.01
        </td>
        <td>-
        </td>
        <td>大 -> ほとんど異常
        </td>
        <td>o([0.0001, 0.5])
        </td>
        <td>データセット中の異常の割合に近い値が望ましい
        </td>
    </tr>
  </table>
  "

  algo1bii: "1-b-ii: Hunter Grove Inspection"
  algo1biiText: "正常画像と少量の異常画像から学習する教師なし学習モデル。"
  algo1biiTable: "
  <table class='hacarus-table'>
    <tr>
        <td>パラメータ
        </td>
        <td>変数名
        </td>
        <td>型 : 範囲
        </td>
        <td>既定値
        </td>
        <td>計算時間への影響
        </td>
        <td>精度への影響
        </td>
        <td>AutoTune (range)
        </td>
        <td>備考
        </td>
    </tr>
    <tr>
        <td>学習サイズ
        </td>
        <td>train_size
        </td>
        <td>int : [1, inf]
        </td>
        <td>10000
        </td>
        <td>大 -> 大
        </td>
        <td>大 -> 大
        </td>
        <td>x
        </td>
        <td>
        </td>
    </tr>
    <tr>
        <td>最小の検査サイズ
        </td>
        <td>min_inspection_size
        </td>
        <td>(int, int) : 0~height, 0~width
        </td>
        <td>(8, 8)
        </td>
        <td>大 -> 大
        </td>
        <td>-
        </td>
        <td>O (4, 8, 16)
        </td>
        <td>(4, 4) or (8,8) or (16,16) が経験的によい。
            <p>
                三つの中から選んでもらうようにしたい。
        </td>
    </tr>
    <tr>
        <td>最小の検査サイズ幅
        </td>
        <td>min_inspection_step
        </td>
        <td>int : [1, inf]
        </td>
        <td>4
        </td>
        <td>大 -> 小
        </td>
        <td>大 -> 小
        </td>
        <td>x
        </td>
        <td>min_inspection_sizeの約数が望ましい。
            <p>
                1のとき一番計算負荷がかかるが、もっとも性能がよい。
        </td>
    </tr>
    <tr>
        <td>最小の検知サイズ
        </td>
        <td>min_detected_area
        </td>
        <td>Float : [1, inf]
        </td>
        <td>None
        </td>
        <td>-
        </td>
        <td>-
        </td>
        <td>x
        </td>
        <td>検出された矩形の面積の閾値
        </td>
    </tr>
    <tr>
        <td>異常部分の拡大率
        </td>
        <td>anomaly_magnification
        </td>
        <td>(int, int) : 0~height, 0~width
        </td>
        <td>(1, 1)
        </td>
        <td>-
        </td>
        <td>-
        </td>
        <td>o(1,3,5)
        </td>
        <td>大きくすると、小さい異常部分を検出できるようになる。ただし過検出も増える。
        </td>
    </tr>
    <tr>
        <td>無視される外周からの幅
        </td>
        <td>ignore_outer
        </td>
        <td>(int, int) : 0~height, 0~width
        </td>
        <td>(0,0)
        </td>
        <td>-
        </td>
        <td>-
        </td>
        <td>x
        </td>
        <td>外周からの無視する領域の幅
            <p>
                画像の縦, 横のピクセル数までの値にする。
        </td>
    </tr>
    <tr>
        <td>特徴量の次元
        </td>
        <td>n_estimators
        </td>
        <td>Int : [1, inf]
        </td>
        <td>100
        </td>
        <td>大->大
        </td>
        <td>大->大
        </td>
        <td>O (10, 50, 100, 200)
        </td>
        <td>
        </td>
    </tr>
    <tr>
        <td>異常とみなせるパッチの割合
        </td>
        <td>contamination
        </td>
        <td>Float : [0, 0.5]
        </td>
        <td>0.01
        </td>
        <td>-
        </td>
        <td>大 -> ほとんど異常
        </td>
        <td>O ([0.0001, 0.5]
        </td>
        <td>学習に使われた異常パッチの割合が望ましい
        </td>
    </tr>
  </table>
  "

  algo2i: "2-i: Mixed Grove Inspection"
  algo2iText: "正常画像と異常画像から学習する教師あり学習モデル。"
  algo2iTable: "
  <table class='hacarus-table'>
    <tr>
        <td>パラメータ
        </td>
        <td>変数名
        </td>
        <td>型 : 範囲
        </td>
        <td>既定値
        </td>
        <td>計算時間への影響
        </td>
        <td>精度への影響
        </td>
        <td>AutoTune (range)
        </td>
        <td>備考
        </td>
    </tr>
    <tr>
        <td>学習サイズ
        </td>
        <td>train_size
        </td>
        <td>int : [1, inf]
        </td>
        <td>1000
        </td>
        <td>大 -> 大
        </td>
        <td>大 -> 大
        </td>
        <td>x
        </td>
        <td>
        </td>
    </tr>
    <tr>
        <td>最小の検査サイズ
        </td>
        <td>min_inspection_size
        </td>
        <td>(int, int) : 0~height, 0~width
        </td>
        <td>(8, 8)
        </td>
        <td>大 -> 大
        </td>
        <td>-
        </td>
        <td>O (4, 8, 16)
        </td>
        <td>(4, 4) or (8,8) or (16,16) が経験的によい。
            <p>
                三つの中から選んでもらうようにしたい。
        </td>
    </tr>
    <tr>
        <td>最小の検査サイズ幅
        </td>
        <td>min_inspection_step
        </td>
        <td>int : [1, inf]
        </td>
        <td>4
        </td>
        <td>大 -> 小
        </td>
        <td>大 -> 小
        </td>
        <td>x
        </td>
        <td>min_inspection_sizeの約数が望ましい。
            <p>
                1のとき一番計算負荷がかかるが、もっとも性能がよい。
        </td>
    </tr>
    <tr>
        <td>最小の検知サイズ
        </td>
        <td>min_detected_area
        </td>
        <td>Float : [1, inf]
        </td>
        <td>None
        </td>
        <td>-
        </td>
        <td>-
        </td>
        <td>x
        </td>
        <td>検出された矩形の面積の閾値
        </td>
    </tr>
    <tr>
        <td>異常部分の拡大率
        </td>
        <td>anomaly_magnification
        </td>
        <td>(int, int) : 0~height, 0~width
        </td>
        <td>(1, 1)
        </td>
        <td>-
        </td>
        <td>-
        </td>
        <td>o(1,3,5)
        </td>
        <td>大きくすると、小さい異常部分を検出できるようになる。ただし過検出も増える。
        </td>
    </tr>
    <tr>
        <td>無視される外周からの幅
        </td>
        <td>ignore_outer
        </td>
        <td>(int, int) : 0~height, 0~width
        </td>
        <td>(0,0)
        </td>
        <td>-
        </td>
        <td>-
        </td>
        <td>x
        </td>
        <td>外周からの無視する領域の幅
            <p>
                画像の縦, 横のピクセル数までの値にする。
        </td>
    </tr>
    <tr>
        <td>特徴量の次元
        </td>
        <td>n_estimators
        </td>
        <td>Int : [1, inf]
        </td>
        <td>100
        </td>
        <td>大->大
        </td>
        <td>大->大
        </td>
        <td>O (10, 50, 100, 200)
        </td>
        <td>
        </td>
    </tr>
    <tr>
        <td>検知領域の異常度の閾値
        </td>
        <td>detected_area_thresh
        </td>
        <td>float : [0, inf]
        </td>
        <td>0.1
        </td>
        <td>-
        </td>
        <td>-
        </td>
        <td>O ([0.1, 0.5])
        </td>
        <td>大きすぎるとほとんど正常、小さすぎるとほとんど異常
        </td>
    </tr>
  </table>
  "